## 문제 : 9934번 완전 이진 트리 

### 입력 
1. k 입력 
- 1 ≤ K ≤ 10
2. 상근이가 방문한 빌딩의 번호 
- 공백으로 구분
- 들어간 순서대로 주어짐 
- 모든 빌딩 번호는 중복되지 않음 
- 구간 [1,2K)에 포함됨 

### 조건 
- 각 레벨에 있는 빌딩의 번호를 구하는 프로그램 
- 가장 처음 상근이는 트리의 루트에 있는 빌딩 앞에 섰다. 
- 현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면 왼쪽 자식으로 이동한다. 
- 현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식이 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌등을 들어가고 종이에 번호를 적는다. 
- 현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다. 
- 현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.

### 출력 
1. k개의 줄에 걸쳐 정답 출력 
- i번째 줄에는 레벨이 i인 빌딩의 번호 출력 
- 출력은 왼쪽에서 부터 오른쪽 순서대로 출력 

```java
import java.util.*;
import java.io.*;

public class Main {
  static int k; 
  static int[] numbers;
  static List<List<Integer>> levels; 
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    // k 입력
    k = Integer.parseInt(br.readLine());

    // 방문한 빌딩 번호 
    int size = (int)Math.pow(2, k) - 1;
    numbers = new int[size];
    
    StringTokenizer st = new StringTokenizer(br.readLine());
    for(int i = 0; i < size; i++) {
      numbers[i] = Integer.parseInt(st.nextToken()); 
    }

    // 각 레벨별 노드를 저장할 리스트 초기화
    levels = new ArrayList<>();
    for(int i = 0; i < k; i++) {
      levels.add(new ArrayList<>());
    }

    // 재귀 탐색 시작
    search(0, size - 1, 0);

    // 결과 출력
    StringBuilder sb = new StringBuilder();
    for(int i = 0; i < k; i++) {
      for(int num : levels.get(i)) {
        sb.append(num).append(" ");
      }
      sb.append("\n");
    }
    System.out.print(sb.toString());
  }

  static void search(int start, int end, int depth) {
    if (start > end) {
      return;
    }
    
    int mid = (start + end) / 2;
    
    levels.get(depth).add(numbers[mid]);
    search(start, mid - 1, depth + 1);
    search(mid + 1, end, depth + 1);
  }
}

```