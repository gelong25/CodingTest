## 문제 : 15666번 N과 M (12)

### 입력 
1. N, M 
- 공백으로 구분 
- 1 ≤ M ≤ N ≤ 8
2. N개의 수 
- 10,000보다 작거나 같은 자연수

### 조건 
- N개의 자연수 중 M개를 고른 수열
- 같은 수를 여러 번 골라도 됨
- 고른 수열은 비내림차순 

### 출력
1. 한 줄에 하나씩 조건을 만족하는 수열 출력 
- 공백으로 구분 
- 중복되는 수열 반복 출력 x
- 수열은 사전으로 증가하는 순으로 출력

```java
import java.util.*;
import java.io.*;

public class Main {
  static StringBuilder sb = new StringBuilder(); 
  static int n, m;
  static int[] arr; 
  static int[] answer; 

  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    // n과 m 입력
    StringTokenizer st = new StringTokenizer(br.readLine());
    n = Integer.parseInt(st.nextToken());
    m = Integer.parseInt(st.nextToken()); 

    // 자연수를 입력 받을 배열 
    arr = new int[n]; 

    // 선택된 수열을 저장할 배열 
    answer = new int[m]; 
    
    // n개의 자연수 입력 
    st = new StringTokenizer(br.readLine()); 
    for(int i = 0; i < n; i++) {
      arr[i] = Integer.parseInt(st.nextToken()); 
    }

    // 오름차순 정렬 
    Arrays.sort(arr); 

    // dfs 함수 호출 
    dfs(0, 0); 

    System.out.println(sb.toString()); 
    
  }

  static void dfs(int depth, int start) {
    // 수열의 depth가 m이면 결과에 값 추가 
    if(depth == m) {
      for(int num : answer) {
        sb.append(num).append(' ');
      }
      sb.append('\n');
      return; 
    }

    // 동일한 depth에서 중복 방지를 위한 변수 
    int last = 0; 

    // start 부터 n-1까지 순회 
    for(int i = start; i < n; i++) {
      // 이전에 선택한 값과 다를 경우 
      if(arr[i] != last) {
        // 중복 방지를 위해 현재 값 저장 
        last = arr[i];
        // 현재 dpeth 위치에 숫자 저장 
        answer[depth] = arr[i];

        // 다음 depth로 이동을 위한 재귀 호출 
        dfs(depth+1, i); 
      }
    }
  }
}
```