## 문제 : 16948번 데스 나이트 

### 입력 
1. 체스판의 크기 
- 5 ≤ N ≤ 200
2. r1, c1, r2, c2
- 공백으로 구분 

### 조건 
- N x N 체스판과 두 좌표가 주어졌을 때 이동하는 최소 이동 횟수를 구하는 프로그램
- 시작은 0, 0
- (r1, c1)에서 시작해 (r2, c2)로 이동 
- 이동 가능한 수: (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)
- 체스판 밖으로 벗어날 수 없음 

### 출력 
1. 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수 출력
- 이동할 수 없는 경우: -1 출력 


```java
import java.util.*;
import java.io.*;

public class Main {
  static int n; 
  static int[][] map; 
  static int[] dx = {-2, -2, 0, 0, 2, 2};
  static int[] dy = {-1, 1, -2, 2, -1, 1};
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 

    // 체크판의 크기 N
    n = Integer.parseInt(br.readLine());

    // 맵 초기화 
    map = new int[n][n];
    // 아직 방문하지 않은 곳은 -1로 초기화  
    for(int i = 0; i < n; i++) {
      Arrays.fill(map[i], -1); 
    }

    // 시작 좌표, 목표 좌표 입력 
    StringTokenizer st = new StringTokenizer(br.readLine());

    int r1 = Integer.parseInt(st.nextToken());
    int c1 = Integer.parseInt(st.nextToken());
    int r2 = Integer.parseInt(st.nextToken());
    int c2 = Integer.parseInt(st.nextToken());

    int answer = bfs(r1, c1, r2, c2);
    System.out.println(answer); 
    
  }

  static int bfs(int x1, int y1, int x2, int y2) {
    ArrayDeque<int[]> queue = new ArrayDeque<>(); 

    map[x1][y1] = 0; 
    queue.offer(new int[]{x1, y1});

    while(!queue.isEmpty()) {
      int[] current = queue.poll();

      int cx = current[0];
      int cy = current[1];

      // 현재 좌표가 도달해야 하는 좌표와 같을 경우 
      if(cx == x2 && cy == y2) {
        return map[cx][cy];
      }

      for(int k = 0; k < 6; k++) {
        int nx = cx + dx[k];
        int ny = cy + dy[k];

        // 체스판 영역을 벗어나는 경우 
        if(nx < 0 || ny < 0 || nx >= n || ny >= n) {
          continue; 
        }

        // 이미 방문한 좌표인 경우 
        if(map[nx][ny] != -1) {
          continue; 
        }

        map[nx][ny] = map[cx][cy] + 1; 
        queue.offer(new int[]{nx, ny}); 
      }
    }

    // 이동할 수 없는 경우 -1 반환 
    return -1; 
  }
}
```