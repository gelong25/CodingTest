## 문제 : 21736번 헌내기는 친구가 필요해 

### 입력
1. 캠퍼스의 크기 N, M
- 공백으로 구분 
- 1 <= N <= 600
- 1 <= M <= 600
2. N개의 줄에 걸쳐 캠퍼스 정보 
- O: 빈 공간
- X: 벽
- I: 도연이
  - I는 한 번만 주어짐 
- P: 사람 

### 조건 
- 도연이가 캠퍼스에서 만날 수 있는 사람의 수를 출력하는 프로그램 
- 이동방법: 벽이 아닌 상하좌우 이동 
- 캠퍼스 밖으로 이동 불가 

### 출력 
1. 도연이가 만날 수 있는 사람의 수

```java
import java.util.*;
import java.io.*;

public class Main {
  static int n, m;
  static int[][] map; 
  static boolean[][] visited; 
  static int cnt = 0; 
  static int[] dx = {0, 0, -1, 1};
  static int[] dy = {-1, 1, 0, 0}; 
  
  public static void main(String[] args)throws IOException{
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    StringTokenizer st = new StringTokenizer(br.readLine());

    // 캠퍼스의 크기 N x M 입력
    n = Integer.parseInt(st.nextToken());
    m = Integer.parseInt(st.nextToken());

    // 캠퍼스 배열 초기화
    map = new int[n][m];

    // 방문 확인 배열 초기화 
    visited = new boolean[n][m]; 

    // 도연이의 위치 좌표 변수 
    int startX = 0;
    int startY = 0; 
    
    // 캠퍼스 정보 입력 
    for(int i = 0; i < n; i++) {
      String line = br.readLine(); 

      for(int j = 0; j < m; j++) {
        char c = line.charAt(j); 

        // 빈 공간: 0, 벽: 1, 사람: 2, 도연이: 3
        if(c == 'O') {
          map[i][j] = 0; 
        } else if(c == 'X') {
          map[i][j] = 1; 
        } else if(c == 'P') {
          map[i][j] = 2; 
        } else if(c == 'I') {
          map[i][j] = 3; 
          startX = i;
          startY = j; 
        }
      }
    }

    dfs(startX, startY); 

    if(cnt == 0) {
      System.out.println("TT");
    } else {
      System.out.println(cnt); 
    }
  }
  
  static void dfs(int x, int y) {
    visited[x][y] = true; 

    // 사람이 있는 경우 
    if(map[x][y] == 2) {
      cnt++; 
    }

    for(int k = 0; k < 4; k++) {
      int nx = x + dx[k];
      int ny = y + dy[k];

      // 범위를 벗어난 경우 
      if(nx < 0 || ny < 0 || nx >= n || ny >= m) {
        continue;
      }

      // 방문 체크 
      if(visited[nx][ny]) {
        continue; 
      }
      
      // 벽을 만난 경우 
      if(map[nx][ny] == 1) {
        continue; 
      }

      // 재귀 호출 
      dfs(nx, ny); 
    }
    
  }
    
}
```