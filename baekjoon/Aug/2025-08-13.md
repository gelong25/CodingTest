## 문제 : 2667번 단지 번호 붙이기 


### 입력 
1. 지도의 크기 N
- 5 <= N <= 25
2. N개의 줄에 N개의 자료 입력
- 0 또는 1로 이루어짐 

### 조건 
- 0과 1로 이루어진 지도가 주어졌을 때 단지수와 단지에 속하는 집의 수를 구하는 프로그램
- 1: 집이 있는 곳
- 0: 집이 없는 곳 
- 단지: 상하좌우 연결된 집 
- 대각선: 연결되지 않은 것 

### 출력 
1. 총 단지수
2. 각 단지 내 집의 수 
- 오름차순 정렬 
- 한 줄에 하나씩 

```java
import java.util.*;
import java.io.*;

public class Main {
    static int n;
    static int[][] map;
    static boolean[][] visited;
    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {-1, 1, 0, 0};

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        // 지도의 크기 N 입력
        n = Integer.parseInt(br.readLine());

        // 지도 배열 초기화
        map = new int[n][n];
        // 방문 확인 배열 초기화
        visited = new boolean[n][n];

        // 지도 입력 
        for(int i = 0; i < n; i++) {
            String str = br.readLine().trim();

            for(int j = 0; j < n; j++) {
                map[i][j] = str.charAt(j) - '0';
            }
        }

        // 단지를 저장할 리스트 선언 
        List<Integer> apts = new ArrayList<>();

        // 지도를 순회하며 단지 탐색 
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < n; j++) {
                // 해당 위치값이 1이고 방문하지 않은 경우 
                if(map[i][j] == 1 && !visited[i][j]) {
                    // bfs 호출 
                    int apt = bfs(i, j);
                    apts.add(apt);
                }
            }
        }

        // 단지수 오름차순 정렬
        Collections.sort(apts);

        StringBuilder sb = new StringBuilder();
        sb.append(apts.size()).append('\n');

        for(int num : apts) {
            sb.append(num).append('\n');
        }
        System.out.print(sb);

    }
    // 단지 크기를 구하는 함수
    static int bfs(int x, int y) {
        Queue<int[]> queue = new LinkedList<>();

        queue.offer(new int[]{x, y});
        visited[x][y] = true;

        // 단지 내 집의 개수를 세는 변수 
        int cnt = 1;

        while(!queue.isEmpty()) {
            int[] current = queue.poll();
            int cx = current[0];
            int cy = current[1];

            for(int k = 0; k < 4; k++) {
                int nx = cx + dx[k];
                int ny = cy + dy[k];

                // 지도를 벗어날 경우 
                if(nx < 0 || ny < 0 || nx >= n || ny >= n) {
                    continue;
                }

                // 이미 방문한 위치일 경우 
                if(visited[nx][ny]) {
                    continue;
                }

                // 집이 없는 곳인 0일 경우 
                if(map[nx][ny] == 0) {
                    continue;
                }

                // 방문 처리 
                visited[nx][ny] = true;

                // 다음 탐색 대상을 큐에 삽입 
                queue.offer(new int[]{nx, ny});

                cnt++;
            }

        }

        return cnt;
    }

}
```