## 문제 : 1926번 그림 


### 입력 
1. 도화지의 세로, 가로 크기 n, m
- 공백으로 구분 
- 1 ≤ n ≤ 500
- 1 ≤ m ≤ 500
2. n+1번 줄까지 그림의 정보 
- 공백으로 구분 
- 0: 색칠 안 된 부분 
- 1: 색칠 된 부분

### 조건 
- 그림이 그려져 있을 때 그림의 개수와 그림 중 넓이가 가장 넓은 것을 출력하는 프로그램 
- 그림은 1로 연결됨
- 상하좌우는 연결된 것 
- 대각선은 떨어진 것 

### 출력 
1. 그림의 개수
2. 가장 넓은 그림의 넓이 
- 그림이 없는 경우: 0 출력 


```java
import java.util.*;
import java.io.*;

public class Main {
    static int[][] paint;
    static int n, m;
    static boolean[][] visited;
    static int[] dx = {0, 0, -1, 1};
    static int[] dy = {-1, 1, 0, 0};

    public static void main(String[] args)throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

        StringTokenizer st = new StringTokenizer(br.readLine());

        // 도화지의 크기 입력 n x m
        n = Integer.parseInt(st.nextToken());
        m = Integer.parseInt(st.nextToken());

        // 그림을 저장할 배열 초기화 
        paint = new int[n][m];

        // 방문 여부를 저장할 배열 초기화 
        visited = new boolean[n][m];

        // 도화지 속 그림의 정보 입력 
        for(int i = 0; i < n; i++) {
            st = new StringTokenizer(br.readLine());

            for(int j = 0; j < m; j++) {
                paint[i][j] = Integer.parseInt(st.nextToken());
            }
        }

        br.close();

        // 제일 넓은 그림의 넓이 
        int max = 0;

        // 그림 구역을 저장할 리스트 선언 
        List<Integer> zone = new ArrayList<>();

        // 도화지를 순회하며 구역 탐색 
        for(int i = 0; i < n; i++) {
            for(int j = 0; j < m; j++) {
                // 색칠된 부분이고 아직 방문하지 않은 경우 
                if(paint[i][j] == 1 && !visited[i][j]) {
                    // bfs 호출 후 변수에 저장 
                    int result = bfs(i, j);
                    // 리스트에 결과 저장 
                    zone.add(result);

                    // 영역이 저장된 값 보다 클 경우 값을 갱신 
                    if(result > max) {
                        max = result;
                    }
                }
            }
        }

        // 그림의 개수 
        int count = zone.size();

        System.out.println(count);
        System.out.println(max);

    }

    static int bfs(int x, int y) {
        Queue<int[]> queue = new LinkedList<>();

        // 큐에 첫 위치 값 저장 후 방문 처리 
        queue.offer(new int[]{x, y});
        visited[x][y] = true;

        // 구역 안의 그림 개수를 셀 변수 
        int cnt = 1;

        while(!queue.isEmpty()) {
            // 큐의 맨 앞의 요소 저장 
            int[] cur = queue.poll();
            // 현재 탐색하는 위치의 x좌표 
            int cx = cur[0];
            // 현재 탐색하는 위치의 y좌표 
            int cy = cur[1];

            for(int k = 0; k < 4; k++) {
                // 현재 위치에서 k번째 방향으로 한 칸 이동환 x좌표 
                int nx = cx + dx[k];
                // 현재 위치에서 k번째 방향으로 한 칸 이동환 y좌표
                int ny = cy + dy[k];

                // 영역을 벗어나는지 판단
                if(nx < 0 || ny < 0 || nx >= n || ny >= m) {
                    continue;
                }

                // 방문 여부, 공백 여부 판단 
                if(visited[nx][ny] || paint[nx][ny] == 0) {
                    continue;
                }

                // 방문 처리 
                visited[nx][ny] = true;

                // 다음에 탐색할 좌표를 큐에 추가
                queue.offer(new int[]{nx, ny});

                // 그림 개수 증가
                cnt++;
            }
        }

        return cnt;
    }
}
```