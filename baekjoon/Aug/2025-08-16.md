## 문제 : 5567번 결혼식

### 입력
1. 동기의 수 n
- 2 ≤ n ≤ 500 
2. 리스트의 길이 m 
- 1 ≤ m ≤ 10000
3. m개 줄에 걸쳐 친구 관계 ai bi
- 공백으로 구분 
- 1 ≤ ai < bi ≤ n 
- ai와 bi가 친구 
- bi와 ai가 친구

### 조건
- 결혼식에 초대할 사람의 수를 구하는 프로그램 
- 자신의 친구와 친구의 친구를 초대함
- 상근이의 학번은 1번

### 출력 
1. 결혼식에 초대하는 동기의 수 

```java
import java.util.*;
import java.io.*;

public class Main {
  static int n, m; 
  static ArrayList<ArrayList<Integer>> graph = new ArrayList<>();
  static boolean[] visited; 
  static StringTokenizer st;
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    // 동기의 수 n 입력 
    n = Integer.parseInt(br.readLine());

    // 리스트의 길이 m 입력 
    m = Integer.parseInt(br.readLine()); 

    // 인접 리스트 초기화
    for(int i = 0; i <= n; i++) {
      graph.add(new ArrayList<>());
    }

    // 방문 확인 배열 초기화 
    visited = new boolean[n+1]; 

    // 친구 관계 입력 
    for(int i = 0; i < m; i++) {
      st = new StringTokenizer(br.readLine());
      int a = Integer.parseInt(st.nextToken());
      int b = Integer.parseInt(st.nextToken());

      graph.get(a).add(b);
      graph.get(b).add(a); 
    }
    br.close(); 

    // bfs 호출 
    bfs(1); 
  }

  static void bfs(int start) {
    Queue<int[]> queue = new LinkedList<>(); 
    queue.add(new int[]{start, 0});

    visited[start] = true; 

    // 동기 수를 셀 변수
    int cnt = 0; 

    while(!queue.isEmpty()) {
      // 탐색할 값 꺼내기 
      int[] current = queue.poll();

      int node = current[0];
      int depth = current[1]; 

      // 만약 depth가 2를 넘을 경우 초대할 사람이 아님 
      if(depth >= 2) {
        continue; 
      }

      // 인접 노드 탐색 
      for(int next : graph.get(node)) {
        // 아직 방문하지 않았을 경우 
        if(!visited[next]) {
          visited[next] = true; 
          queue.add(new int[]{next, depth+1});

          cnt++; 
        }
      }
      
    }

    System.out.println(cnt);
    
  }
}
```