## 문제 : 1991번 트리 순회 


### 입력 
1. 이진 트리의 노드 개수 N
- 1 ≤ N ≤ 26
2. N개의 줄에 걸쳐 각 노드와 그의 왼쪽, 오른쪽 자식 노드 
- 공백으로 구분 
- 노드의 이름: A부터 차례대로 알파벳 대문자로 매겨짐 
- 루트 노드: A
- 자식이 없는 경우: . 

### 조건
- 이진 트리가 입력됐을 때 전위, 중위, 후위 순회 결과를 반환하는 프로그램 


### 출력 
1. 전위 순회 결과 
2. 중위 순회 결과
3. 후위 순회 결과 
- 각 줄의 N개의 알파벳을 공백 없이 출력 


```java
import java.util.*;
import java.io.*;

public class Main {
  static int[] leftArr = new int[26];
  static int[] rightArr = new int[26];
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 

    // 이진 트리 노드의 개수 N
    int n = Integer.parseInt(br.readLine());

    // 각 노드와 왼쪽, 오른쪽 자식 노드 입력  
    for(int i = 0; i < n; i++) {
      StringTokenizer st = new StringTokenizer(br.readLine()); 

      char node = st.nextToken().charAt(0); 
      char left = st.nextToken().charAt(0);
      char right = st.nextToken().charAt(0); 

      int index = node - 'A'; 
      leftArr[index] = (left == '.') ? -1 : (left - 'A');
      rightArr[index] = (right == '.') ? -1 : (right - 'A'); 
    }
    
    // 전위 순회
    preOrder(0);
    System.out.println(); 

    // 중위 순회
    inOrder(0); 
    System.out.println(); 

    // 후위 순회 
    postOrder(0); 
    System.out.println(); 
  }

  static void preOrder(int current) {
    if(current == -1) {
      return; 
    }

    System.out.print((char)(current + 'A'));
    preOrder(leftArr[current]);
    preOrder(rightArr[current]); 
  }

  static void inOrder(int current) {
    if(current == -1) {
      return; 
    }

    inOrder(leftArr[current]);
    System.out.print((char)(current + 'A'));
    inOrder(rightArr[current]); 
  }

  static void postOrder(int current) {
    if(current == -1) {
      return; 
    }

    postOrder(leftArr[current]); 
    postOrder(rightArr[current]);
    System.out.print((char)(current + 'A'));   
    
  }
}
```