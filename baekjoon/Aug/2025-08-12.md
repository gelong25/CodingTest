## 문제 : 2178번 미로 탐색


### 입력
1. 두 정수 N, M
- 공백으로 구분 
- 2 ≤ N, M ≤ 100
2. N개의 줄에 걸쳐 M개의 정수로 미로 입력 

### 조건 
- 미로가 주어졌을 때 (1, 1)에서 (N, M)으로 이동 할 때 지나야 하는 최소 칸 수를 구하는 프로그램
- 인접한 칸으로만 이동 가능 
- 칸을 셀 때는 시작 위치와 도착 위치도 포함함 
- 1은 이동할 수 있는 칸
- 0은 이동할 수 없는 칸

### 출력 
1. 지나야 하는 최소 칸 수 출력 
- 항상 도착 위치로 이동할 수 있는 경우만 주어짐 

```java
import java.util.*;
import java.io.*;

public class Main {
  static int n, m; 
  static int[][] map; 
  static boolean[][] visited; 
  static int[] dx = {0, 0, -1, 1};
  static int[] dy = {-1, 1, 0, 0}; 
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

    StringTokenizer st = new StringTokenizer(br.readLine());
    
    // 정수 n, m 입력 
    n = Integer.parseInt(st.nextToken());
    m = Integer.parseInt(st.nextToken()); 

    // 미로를 입력받을 배열 초기화 
    map = new int[n][m]; 
    // 방문 여부를 확인할 배열 초기화 
    visited = new boolean[n][m]; 

    // 미로 입력 
    for(int i = 0; i < n; i++) {
      String str = br.readLine().trim(); 
      
      for(int j = 0; j < m; j++) {
        map[i][j] = str.charAt(j) - '0'; 
      }
    }

    // bfs 호출
    bfs(0, 0); 

    System.out.println(map[n-1][m-1]); 

    
    
  }
  static void bfs(int x, int y) {
    Queue<int[]> queue = new LinkedList<>();
    // 큐에 시작 좌표 추가 
    queue.add(new int[] {0, 0}); 

    // 시작 좌표 방문 처리 
    visited[x][y] = true; 

    while(!queue.isEmpty()) {
      int[] current = queue.poll(); 

      // 현재 방문한 칸의 좌표 
      int cx = current[0];
      int cy = current[1];

      for(int i = 0; i < 4; i++) {
        // 인접한 칸의 좌표 
        int nx = cx + dx[i];
        int ny = cy + dy[i]; 

        // 범위 밖인 경우 
        if(nx < 0 || ny < 0 || nx >= n || ny >= m) {
          continue; 
        }
        // 이미 방문 했거나 벽인 경우 
        if(visited[nx][ny] || map[nx][ny] == 0) {
          continue; 
        }

        // 방문 처리 
        visited[nx][ny] = true;

        // 거리 계산 
        map[nx][ny] = map[cx][cy] + 1; 

        // 큐에 삽입 
        queue.add(new int[]{nx, ny});
      }
    }
  }
}
```