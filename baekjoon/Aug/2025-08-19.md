## 문제 : 1743번 음식물 피하기 

### 입력
1. 통로의 세로 길이 N, 가로 길이 M, 음식물 쓰레기의 개수 K
- 공백으로 구분 
- 1 ≤ N ≤ 100
- 1 ≤ M ≤ 100
- 1 ≤ K ≤ N×M
2. K개의 줄에 걸쳐 음식물이 떨어진 좌표 r, c
- 공백으로 구분 
- 좌표는 중복되지 않음 


### 조건
- N x M 크기의 통로가 주어졌을 때 가장 큰 음식물의 크기를 구하는 프로그램 
- 상하좌우로 인접한 음식물은 붙어 있는 것으로 취급함 

### 출력 
1. 음식물 중 가장 크기가 큰 것을 출력 


```java
import java.util.*;
import java.io.*;

public class Main {
  static int n, m, k; 
  static int[][] map; 
  static boolean[][] visited; 
  static int[] dx = {0, 0, -1, 1}; 
  static int[] dy = {-1, 1, 0, 0}; 
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 

    StringTokenizer st = new StringTokenizer(br.readLine());

    // 통로의 세로 길이 n 입력 
    n = Integer.parseInt(st.nextToken());
    // 가로 길이 m 입력
    m = Integer.parseInt(st.nextToken());
    // 음식물 쓰레기의 개수 k 입력
    k = Integer.parseInt(st.nextToken());

    // 통로 배열 초기화 
    map = new int[n][m]; 

    // 방문 여부 배열 초기화 
    visited = new boolean[n][m]; 

    // 음식물이 떨어진 좌표 r,c 입력 
    for(int i = 0; i < k; i++) {
      st = new StringTokenizer(br.readLine());

      int r = Integer.parseInt(st.nextToken());
      int c = Integer.parseInt(st.nextToken()); 

      // 입력 좌표에서 1 빼기 
      r -= 1;
      c -= 1; 

      map[r][c] = 1; 
    }

    // 가장 큰 음식물의 크기를 구할 변수 
    int max = 0; 

    // 전체 통로 탐색 
    for(int i = 0; i < n; i++) {
      for(int j = 0; j < m; j++) {
        if(map[i][j] == 1 && !visited[i][j]) {
          max = Math.max(max, bfs(i, j)); 
        }
      }
    }

    System.out.println(max); 

  }

  static int bfs(int x, int y) {
    Queue<int[]> queue = new LinkedList<>();
    
    queue.add(new int[]{x, y}); 
    visited[x][y] = true; 

    // 현재 음식물의 크기를 저장할 변수 
    int size = 1; 

    while(!queue.isEmpty()) {
      int[] current = queue.poll();

      int cx = current[0];
      int cy = current[1];

      // 상하좌우 탐색 
      for(int i = 0; i < 4; i++) {
        int nx = cx + dx[i];
        int ny = cy + dy[i];

        // 통로 범위를 벗어나지 않고
        if(nx >= 0 && ny >= 0 && nx < n && ny < m) {
          // 아직 방문하지 않고 음식물이 있는 경우  
          if(!visited[nx][ny] && map[nx][ny] ==1) {
            visited[nx][ny] = true; 
            queue.add(new int[]{nx, ny});
            size++; 
          }
        }
      }
    }

    return size;
    
  }
}
```