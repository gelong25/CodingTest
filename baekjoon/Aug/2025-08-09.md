## 문제 : 10026번 적록색약 

### 입력 
1. n
- 1 <= N <= 100
2. N개의 줄에 걸쳐 그림 
- R, G, B 중 하나로 구성됨

### 조건 
- N x N 그리드가 주어짐 
- 각 칸은 R, G, B 중 하나로 주성됨
- 같은 색상이 상하좌우로 인접한 경우 같은 구역으로 인정 
- 하지만 적록색약의 경우 R, G의 차이를 느끼지 못함 
- 적록색약인 사람과 아닌 사람이 봤을 때 구역수를 출력하는 프로그램 

### 출력 
1. 적록색약이 아닌 사람이 봤을 때와 적록색약인 사람이 봤을 때의 구역의 수
- 공백으로 구분 

```java
import java.io.*;
import java.util.*;

public class Main {
    static int n;
    static char[][] grid;      
    static char[][] gridRG;   
    static boolean[][] visited1;   
    static boolean[][] visited2;   
    static final int[] dx = {1, -1, 0, 0};
    static final int[] dy = {0, 0, 1, -1};

    public static void main(String[] args) throws Exception {
      BufferedReader br = new BufferedReader(new InputStreamReader(System.in));

      // n 입력 
      n = Integer.parseInt(br.readLine().trim());

      // 그리드 저장할 배열 초기화 
      grid = new char[n][n];
      gridRG = new char[n][n];

      // grb 입력 
      for (int i = 0; i < n; i++) {
           String line = br.readLine().trim(); 
          for (int j = 0; j < n; j++) {
              char c = line.charAt(j);
              grid[i][j] = c;
               gridRG[i][j] = (c == 'G') ? 'R' : c; // 적록색약은 G를 R로
          }
       }

      // 방문 확인 배열 초기화 
      visited1 = new boolean[n][n];
      visited2 = new boolean[n][n];

      // 적록색약 x 개수 
      int cnt1 = 0;
      // 적록색약 o 개수 
      int cnt2 = 0;

      // 적록색약 x 영역 수 세기
      for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
          // 아직 방문하지 않은 경우 bfs 호출 
          if (!visited1[i][j]) {
            bfs(i, j, grid, visited1);
            cnt1++;
          }
        }
      }

       // 적록색약 o 영역 수 세기
       for (int i = 0; i < n; i++) {
          for (int j = 0; j < n; j++) {
            // 아직 방문하지 않은 경우 bfs 호출 
            if (!visited2[i][j]) {
              bfs(i, j, gridRG, visited2);
              cnt2++;
            }
          }
       }
      
      System.out.println(cnt1 + " " + cnt2);
    
    }

    static void bfs(int sx, int sy, char[][] board, boolean[][] visited) {
      char target = board[sx][sy];
      Queue<int[]> q = new ArrayDeque<>();

      // 시작점 방문 처리 
      visited[sx][sy] = true;
      q.offer(new int[]{sx, sy});
      
      while (!q.isEmpty()) {
        int[] cur = q.poll();
        int x = cur[0], y = cur[1];

        // 인접칸 탐색 
        for (int i = 0; i < 4; i++) {
          int nx = x + dx[i];
          int ny = y + dy[i];

          // 범위 밖일 경우 
          if (nx < 0 || ny < 0 || nx >= n || ny >= n) {
            continue;
          }

          // 방문한 칸일 경우 
          if (visited[nx][ny]) {
            continue;
          }

          // 색상이 다를 경우 
          if (board[nx][ny] != target) {                  
            continue;
          }

          // 방문 처리 
          visited[nx][ny] = true;
          // 큐에 추가 
          q.offer(new int[]{nx, ny});
        
        }
      }
    }
}

```