## 문제 : 2468번 안전 영역 

### 입력
1. 행과 열의 개수 N
- 2 <= N <= 100
2. N개의 줄에 걸쳐 N x N 행과 열에 대한 높이 정보 
- 공백으로 구분 
- 1 <= 높이 <= 100 

### 조건 
- 지역의 높이 정보가 주어졌을 때 물에 잠기지 않는 안전 영역의 최대 개수를 구하는 프로그램 
- N x N 지역의 높이가 주어짐 
- 장마 높이가 4일 경우 4 이하인 지역은 물에 잠김 

### 출력 
1. 안전한 영역의 최대 개수 출력

```java
import java.util.*;
import java.io.*;

public class Main {
  static int n; 
  static int[][] map; 
  static boolean[][] visited; 
  static int[] dx = {0, 0, -1, 1};
  static int[] dy = {-1, 1, 0, 0}; 
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    StringTokenizer st; 

    // 행과 열을 나타내는 수 n 입력 
    n = Integer.parseInt(br.readLine()); 

    // 지역을 저장할 배열 초기화 
    map = new int[n][n]; 

    // 방문 여부를 확인할 배열 초기화 
    visited = new boolean[n][n]; 

    // 영역 중 가장 높은 수를 저장 할 변수
    int max = 0; 

    // 각 영역의 높이 저장 
    for(int i = 0; i < n; i++) {
      st = new StringTokenizer(br.readLine());

      for(int j = 0; j < n; j++) {
        map[i][j] = Integer.parseInt(st.nextToken()); 

        if(map[i][j] > max) {
          max = map[i][j]; 
        }
      }
    }    

    // 정답으로 반환 할 변수 
    int answer = 1; 

    for(int i = 0; i < max; i++) {
      // 방문 여부 확인 배열 초기화 
      visited = new boolean[n][n]; 

      // bfs 함수 호출 및 최대값 갱신 
      answer = Math.max(answer, bfs(i)); 
    }

    System.out.println(answer); 
    
  }

  static int bfs(int h) {
    Queue<int[]> queue = new LinkedList<>(); 
    int cnt = 0; 

    for(int i = 0; i < n; i++) {
      for(int j = 0; j < n; j++) {
        // 새로운 안전 영역을 발견할 경우 
        if(!visited[i][j] && map[i][j] > h) {
          cnt++; 
          visited[i][j] = true; 
          queue.offer(new int[]{i, j}); 

          while(!queue.isEmpty()) {
            int[] current = queue.poll();

            int cx = current[0];
            int cy = current[1]; 

            // 상하좌우 탐색 
            for(int k = 0; k < 4; k++) {
              int nx = cx + dx[k];
              int ny = cy + dy[k]; 

              if(nx >= 0 && ny >= 0 && nx < n && ny < n) {
                if(!visited[nx][ny] && map[nx][ny] > h) {
                  visited[nx][ny] = true; 
                  queue.offer(new int[]{nx, ny}); 
                }
              }
            }
          }
          
        }
      }
    }

    return cnt; 
  }

}
```