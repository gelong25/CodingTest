## 문제 : 1260번 DFS와 BFS


### 입력 
1. 정점의 개수 N, 간선의 개수 M, 탐색을 시작할 정점의 번호 V
- 공백으로 구분 
- 1 ≤ N ≤ 1,000
- 1 ≤ M ≤ 10,000
2. M개의 줄에 걸쳐 간선을 연결하는 두 정점의 번호 
- 공백으로 구분 
- 양방향 

### 조건 
- DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램
- 방문할 수 있는 정점이 여러 개인 경우 정점 번호가 작은 것을 먼저 방문
- 더 이상 방문할 수 있는 점이 없는 경우 종료 
- 정점 번호 : 1번 부터 N번 

### 출력 
1. DFS 수행 결과 
2. BFS 수행 결과 
- V부터 방문된 점을 순서대로 출력 

```java
import java.util.*;
import java.io.*;

public class Main {
  static boolean[] visited; 
  static List<Integer>[] graph; 
  
  public static void main(String[] args)throws IOException {
    BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    
    StringTokenizer st = new StringTokenizer(br.readLine());

    // 정점의 개수 n, 간서의 개수 m, 탐색을 시작할 정점의 번호 v
    int n = Integer.parseInt(st.nextToken());
    int m = Integer.parseInt(st.nextToken());
    int v = Integer.parseInt(st.nextToken());

    visited = new boolean[n+1]; 

    // graph 초기화
    graph = new ArrayList[n+1];
    for(int i = 1; i <= n; i++) {
      graph[i] = new ArrayList<>(); 
    }

    // 간선 입력 
    for(int i = 0; i < m; i++) {
      st = new StringTokenizer(br.readLine());

      int ver1 = Integer.parseInt(st.nextToken());
      int ver2 = Integer.parseInt(st.nextToken());

      graph[ver1].add(ver2);
      graph[ver2].add(ver1);
    }

    // 오름차순 정렬 
    for(int i = 1; i <= n; i++) {
      Collections.sort(graph[i]);
    }

    // dfs 함수 호출 
    dfs(v);
    System.out.println();

    // visited 초기화 
    Arrays.fill(visited, false); 
    // bfs 함수 호출 
    bfs(v); 
  }

  static void dfs(int current) {
    visited[current] = true;

    System.out.print(current + " ");

    for(int next : graph[current]) {
      if(!visited[next]) {
        dfs(next); 
      }
    }
  }

  static void bfs(int start) {
    Queue<Integer> queue = new LinkedList<>();
    visited[start] = true; 
    queue.offer(start); 

    while(!queue.isEmpty()) {
      int current = queue.poll(); 
      System.out.print(current + " ");

      for(int next : graph[current]) {
        if(!visited[next]) {
          visited[next] = true;
          queue.offer(next); 
        }
      }
    }
  }
}
```